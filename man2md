#!/usr/bin/awk -f
# man2md generate a markdown document from a man page
# man2md is in public domain

BEGIN {
	example = 0
	bullet = 0
	indent = 0
	emphasis = ""
}

# remove the initial .SOMETHING tag
function removetag() {
	sub("^\...? *", "")
}

# process twofold font markup (.IR, .BR, etc)
function twotags(m1, m2, n, beg, i) {
	if (example)
		m1 = ""
		m2 = ""
	removetag()
	beg = 1
	if (match($0, "\"")) {
		n = split($0, a, "\"")
		if (n > 0 && a[n] == "")
			n--
		if (n > 1 && a[1] == "")
			beg = 2
	} else {
		n = split($0, a)
	}
	$0 = ""
	for (i = beg; i <= n; i++) {
		if ((i - beg + 1) % 2) {
			sub("^ *", "&" m1, a[i])
			sub(" *$", m1 "&", a[i])
		} else {
			sub("^ *", "&" m2, a[i])
			sub(" *$", m2 "&", a[i])
		}
		$0 = $0 a[i]
	}
	$0 = $0 " "
}

# process onefold font markup (.B, .I)
function onetag(m) {
	removetag()
	if (example)
		m = ""
	if (match($0, "^\"")) {
		sub("^\"", "")
		sub("\"$", "")
	}
	$0 = sprintf(m "%s" m " ", $0)
}

# process inline markup
function inline(n, c) {
	gsub("\\\\\\*?\\(dq", "\"")             # double quote
	gsub("\\\\\\*?\\(lq", "“")              # left double quote
	gsub("\\\\\\*?\\(rq", "”")              # right double quote
	for (i in ds)                           # .ds definitions
		gsub("\\\\\\*\\(" i, ds[i])
	gsub("\\\\-", "-")                      # hyphen
	gsub("\\\\( |~)", " ")                  # unbreakable space (converted to regular space)
	gsub("\\\\0", " ")                      # digit-size space (converted to regular space)
	gsub("\\\\(\\||\\^)", "")               # 1/6th and 1/12th space (ignored)
	gsub("\\\\&", "")                       # zero-width character (ignored)
	gsub("\\\\s([+-]?[0-9]|\\([+-]?[0-9][0-9]|[+-]?\\([0-9][0-9])", "") # font size change (ignored)
	while ((n = match($0, "\\\\f.")) != 0) {        # inline font change
		c = substr($0, n + 2, 1)
		if (c == "B") {
			emphasis = "**"
		} else if (c == "I") {
			emphasis = "_"
		}
		if (example) {
			emphasis = ""
		}
		sub("\\\\f.", oldemphasis emphasis)
		oldemphasis = emphasis
		emphasis = ""
	}
	gsub("\\\\e", "\\")                     # backslash
}

# get initial indentation
function getindentation(indent, i, str) {
	str = ""
	for (i = 0; i < indent; i++) {
		str = str "    "
	}
	return str
}

# remove normal comment
/^\.\\"/ {
	$0 = ""
	ignore = 1
}

# remove inline comments and replace `` quotes
{
	sub("\\\\\".*$", "")
	if (!example) {
		gsub("``", "“")                 # replace ``...'' with “...”
		gsub("''", "”")                 # replace ``...'' with “...”
	}
}

# conditional markup (ignored)
/^\.(if|ie|el) / {
	if (match($0, "\\\\\\{") != 0) {
		while (match($0, "^\\.\\\\\\}") == 0) {
			getline
		}
	}
	$0 = ""
	ignore = 1
}

# ignored markup
/^\.ig ?/ {
	end = $2
	while (match($0, "^\\.\\.$") == 0 && match($0, "^\\." end "$") == 0) {
		getline
	}
	$0 = ""
	ignore = 1
}

# add space after non-example lines
/^[^.]/ {
	if (!example)
		$0 = $0 " "
}

# normal macro definition (ignored)
/^\.de / {
	while (match($0, "^\\.\\.$") == 0) {
		getline
	}
	$0 = ""
	ignore = 1
}

# inline macro definition
/^\.ds / {
	removetag()
	macro = $1
	sub("^[^ ]* ", "")
	ds[macro] = $0
	$0 = ""
	ignore = 1
}

# page control (ignored)
/^\.(bp|ne|sv|os) ?/ {
	$0 = ""
	ignore = 1
}

# spacing control (ignored)
/^\.sp ?/ {
	$0 = ""
	ignore = 1
}

# indentation control (ignored)
/^\.in ?/ {
	$0 = ""
	ignore = 1
}

# temporary indentation control (ignored)
/^\.ti ?/ {
	$0 = ""
	ignore = 1
}

# adjust empty space before paragraph (ignored)
/^\.PD/ {
	$0 = ""
	ignore = 1
	pd = 1
}

# title heading
/^\.TH / {
	$0 = sprintf("# %s(%s)\n", $2, $3)
}

# section heading
/^\.SH / {
	removetag()
	$0 = sprintf("\n\n## %s\n\n", $0)
}

# subsection heading
/^\.SS / {
	removetag()
	$0 = sprintf("\n\n### %s\n\n", $0)
}

# new paragraph
/^\.(PP|P|LP|IP)$/ {
	initial = "\n"
	indentation = getindentation(indent)
	if (rs) {
		initial = ""
		indentation = ""
	}
	$0 = initial "\n" indentation
}

# new titled paragraph (converted to definition list item)
/^\.TP ?/ {
	initial = "\n"
	indentation = getindentation(indent)
	if (rs) {
		initial = ""
		indentation = ""
	}
	$0 = initial indentation "* "
	tp = 2
}

# begin indented section
/^\.RS$/ {
	rs = 2
	indent++
	indentation = getindentation(indent)
	$0 = "\n\n" indentation
}

# end indented section
/^\.RE$/ {
	$0 = ""
	indent--
}

# begin example (converted as ```)
/^\.EX$/ {
	example = 1
	$0 = "\n```"
}

# end example (converted as ```)
/^\.EE$/ {
	example = 0
	$0 = "```\n"
}

# no-fill mode
/^\.nf$/ {
	example = 1
	$0 = "\n```"
}

# fill mode
/^\.fi$/ {
	example = 0
	$0 = "```\n"
}

# line break
/^\.br$/ {
	indentation = getindentation(indent)
	$0 = "\n" indentation
}

# multi-line font changing (ignored)
/^\.ft ?/ {
	$0 = ""
	ignore = 1
}

# bold font
/^\.B / {
	onetag("**")
}

# italic font
/^\.I / {
	onetag("_")
}

# roman-to-bold font
/^\.RB / {
	twotags("", "**")
}

# bold-to-roman font
/^\.BR / {
	twotags("**", "")
}

# bold-to-italic font
/^\.BI / {
	twotags("**", "_")
}

# italic-to-bold font
/^\.IB / {
	twotags("_", "**")
}

# italic-to-roman font
/^\.IR / {
	twotags("_", "")
}

# roman-to-italic font
/^\.RI / {
	twotags("", "_")
}

# process and print line
{
	inline()
	if (!example) {
		# this is necessary for <...> don't be interpreted as an html tag
		gsub("<", "\\<")
	}
	if ($0 == "\\(bu ") {           # check if content is a bullet
		$0 = ""
		bullet = 1
	}
	printf "%s", $0
	if (example && !ignore)
		print ""
	if (pd == 0) {
		indentation = getindentation(indent)
		if (tp == 1 && bullet == 0) {
			printf "\n\n" indentation "  "
		}
		if (tp)
			tp--
	}
	if (rs)
		rs--
	pd = 0
	bullet = 0
	ignore = 0
}
